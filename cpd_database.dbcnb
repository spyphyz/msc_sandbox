[{"kind":1,"language":"markdown","value":"CREATING AND ACCESSING A CPD database"},{"kind":2,"language":"sql","value":"CREATE TABLE objects\n( id  INT(10) NOT NULL PRIMARY KEY auto_increment \n, Title VARCHAR(255) NOT NULL\n, 'Date' DATE  \n, Comment VARCHAR(500)\n);\nCREATE TABLE tags\n( id  INT(10) NOT NULL PRIMARY KEY auto_increment \n, tag VARCHAR(55) UNIQUE NOT NULL default ''\n);\nCREATE TABLE objects_tags_map\n( obj_id  INT(10) NOT NULL default '0'\n, tag_id  INT(10) NOT NULL default '0'\n, PRIMARY KEY (obj_id, tag_id)\n, FOREIGN KEY (obj_id) REFERENCES objects (id)\n, FOREIGN KEY (tag_id) REFERENCES tags (id)\n, INDEX       (tag_id, obj_id)\n);\n"},{"kind":1,"language":"markdown","value":"The following is from: https://stackoverflow.com/questions/3508207/best-practice-for-storing-tags-in-a-database "},{"kind":2,"language":"sql","value":"CREATE INDEX idx_tag_name ON tags(tag);\nCREATE INDEX idx_title ON objects(Title);\nCREATE INDEX idx_item_id ON object_tags_map(obj_id);\nCREATE INDEX idx_tag_id ON object_tags_map(tag_id);"},{"kind":1,"language":"markdown","value":"To retrieve items with their associated tags, you can use a SQL join:\n(modified from: https://www.quora.com/What-is-the-best-and-easy-way-to-store-tags-in-MySQL-database)"},{"kind":2,"language":"sql","value":"SELECT i.id, i.Title, GROUP_CONCAT(t.tag) AS tags FROM objects i \nLEFT JOIN object_tags_map it ON i.id = it.obj_id \nLEFT JOIN tags t ON it.tag_id = t.id \nGROUP BY i.id; "},{"kind":1,"language":"markdown","value":"To select objects based on their tags; the following 2 cells are single tag search and multi-tag (AND) search\nhttps://www.quora.com/How-would-I-search-a-MySQL-database-with-tags\nAlso want to set up to perform an OR search and a NOT search"},{"kind":2,"language":"sql","value":"SELECT i.* \nFROM objects i \nJOIN object_tags_map it ON i.id = it.obj_id \nJOIN tags t ON it.tag_id = t.id \nWHERE t.tag = 'physics'; "},{"kind":2,"language":"sql","value":"SELECT i.* \nFROM objects i \nJOIN object_tags_map it ON i.id = it.obj_id \nJOIN tags t ON it.tag_id = t.id \nWHERE t.tag IN ('physics', 'mysql') \nGROUP BY i.id \nHAVING COUNT(DISTINCT t.id) = 2;  -- Adjust the number based on how many tags you are searching for "},{"kind":1,"language":"markdown","value":"AND, OR and AND-NOT searches (in each of the 3 cells below)\nFrom: http://howto.philippkeller.com/2005/04/24/Tags-Database-schemas/\nMore logic searches get more complicated! So maybe just stick to these 4 options for max 3 tags. "},{"kind":2,"language":"sql","value":"-- AND search algorythm\n-- e.g. physics + mysql + php\nSELECT b.*\nFROM object_tags_map bt, objects b, tags t\nWHERE bt.tag_id = t.id\nAND (t.tag IN ('physics', 'mysql', 'php'))\nAND b.id = bt.obj_id\nGROUP BY b.id\nHAVING COUNT(b.id) = 2;"},{"kind":2,"language":"sql","value":"-- OR search algorythm\n-- e.g. physics | mysql | php\nSELECT b.*\nFROM object_tags_map bt, objects b, tags t\nWHERE bt.tag_id = t.id\nAND (t.tag IN ('physics', 'mysql', 'php'))\nAND b.id = bt.obj_id\nGROUP BY b.id;"},{"kind":2,"language":"sql","value":"-- AND then AND NOT search algorythm\n-- e.g. physics + mysql - php\nSELECT b. *\nFROM objects b, object_tags_map bt, tags t\nWHERE b.id = bt.obj_id\nAND bt.tag_id = t.id \nAND (t.tag IN ('physics', 'mysql', 'php'))\nAND b.id NOT IN (SELECT b.id FROM objects b, object_tags_map bt, tags t WHERE b.id = bt.obj_id AND bt.tag_id = t.id AND t.tag = 'php')\nGROUP BY b.id\nHAVING COUNT(b.id) = 3;"},{"kind":2,"language":"sql","value":"-- OR, then AND-NOT search algorythm\n-- e.g. physics | mysql - php\nSELECT b. *\nFROM objects b, object_tags_map bt, tags t\nWHERE b.id = bt.obj_id\nAND bt.tag_id = t.id \nAND (t.tag IN ('physics', 'mysql', 'php'))\nAND b.id NOT IN (SELECT b.id FROM objects b, object_tags_map bt, tags t WHERE b.id = bt.obj_id AND bt.tag_id = t.id AND t.tag = 'php')\nGROUP BY b.id;"},{"kind":1,"language":"markdown","value":"\n"},{"kind":1,"language":"markdown","value":"From: https://www.reddit.com/r/SQL/comments/1hd6cg2/best_tagging_solution_for_an_object_having/\nAlso see: http://howto.philippkeller.com/2005/04/24/Tags-Database-schemas/ \n\nThe “Toxi” solution (3 tables one holds the objects, one holds the tags and their IDs and the other relates them) \n\nThe relationship table object_tags has a primary key which prevents you from adding the same tag to the same object more than once, and which, because it's also an index, allows for rapid retrieval of all tags for a give object\n\nit also has an additional index which allows for rapid retrieval of all objects for a give tag\n\nthus the actual rows of object_tags will never be retrieved, because any query will use one of those two indexes instead (search \"covering query\")\n\nhowever, it does mean that any time you want objects and their tags, or tags and their objects, you will have to do two joins \n\nNeed to work out if any lines need auto-incremented.\n\n\n\nCreate a view that does the joins for you. Then you can query the view. "},{"kind":2,"language":"sql","value":"SELECT * FROM cpd WHERE MATCH (Tags) AGAINST ('+physics +mysql' IN BOOLEAN MODE);"},{"kind":2,"language":"sql","value":"SELECT o.* FROM cpd_test.cpd AS o;\nSELECT * FROM cpd_cpd WHERE MATCH(`CPD activity undertaken`) AGAINST('\"Engineering Council\"' 'CPD' IN BOOLEAN MODE);"},{"kind":2,"language":"sql","value":""}]