[{"kind":1,"language":"markdown","value":"CREATING AND ACCESSING A CPD database"},{"kind":2,"language":"sql","value":"CREATE TABLE objects\n( id  INT(10) NOT NULL PRIMARY KEY auto_increment \n, Title VARCHAR(255) NOT NULL\n, 'Date' DATE  \n, Comment VARCHAR(500)\n);\nCREATE TABLE tags\n( id  INT(10) NOT NULL PRIMARY KEY auto_increment \n, tag VARCHAR(55) UNIQUE NOT NULL default ''\n);\nCREATE TABLE objects_tags_map\n( obj_id  INT(10) NOT NULL default '0'\n, tag_id  INT(10) NOT NULL default '0'\n, PRIMARY KEY (obj_id, tag_id)\n, FOREIGN KEY (obj_id) REFERENCES objects (id)\n, FOREIGN KEY (tag_id) REFERENCES tags (id)\n, INDEX       (tag_id, obj_id)\n);\n"},{"kind":1,"language":"markdown","value":"The following is from: https://stackoverflow.com/questions/3508207/best-practice-for-storing-tags-in-a-database "},{"kind":2,"language":"sql","value":"CREATE INDEX idx_tag_name ON tags(tag);\nCREATE INDEX idx_title ON objects(Title);\nCREATE INDEX idx_item_id ON object_tags_map(obj_id);\nCREATE INDEX idx_tag_id ON object_tags_map(tag_id);"},{"kind":1,"language":"markdown","value":"To retrieve items with their associated tags, you can use a SQL join:\n(modified from: https://www.quora.com/What-is-the-best-and-easy-way-to-store-tags-in-MySQL-database)"},{"kind":2,"language":"sql","value":"SELECT i.id, i.Title, GROUP_CONCAT(t.tag) AS tags FROM objects i \nLEFT JOIN object_tags_map it ON i.id = it.obj_id \nLEFT JOIN tags t ON it.tag_id = t.id \nGROUP BY i.id; "},{"kind":1,"language":"markdown","value":"To select objects based on their tags; the following 2 cells are single tag search and multi-tag (AND) search\nhttps://www.quora.com/How-would-I-search-a-MySQL-database-with-tags\nAlso want to set up to perform an OR search and a NOT search"},{"kind":2,"language":"sql","value":"SELECT i.* \nFROM objects i \nJOIN object_tags_map it ON i.id = it.obj_id \nJOIN tags t ON it.tag_id = t.id \nWHERE t.tag = 'physics'; "},{"kind":2,"language":"sql","value":"SELECT i.* \nFROM objects i \nJOIN object_tags_map it ON i.id = it.obj_id \nJOIN tags t ON it.tag_id = t.id \nWHERE t.tag IN ('physics', 'mysql') \nGROUP BY i.id \nHAVING COUNT(DISTINCT t.id) = 2;  -- Adjust the number based on how many tags you are searching for "},{"kind":1,"language":"markdown","value":"AND, OR and AND-NOT searches (in each of the 3 cells below)\nFrom: http://howto.philippkeller.com/2005/04/24/Tags-Database-schemas/"},{"kind":2,"language":"sql","value":"SELECT b.*\nFROM tagmap bt, bookmark b, tag t\nWHERE bt.tag_id = t.tag_id\nAND (t.name IN ('bookmark', 'webservice', 'semweb'))\nAND b.id = bt.bookmark_id\nGROUP BY b.id\nHAVING COUNT( b.id )=3"},{"kind":2,"language":"sql","value":"SELECT b.*\nFROM tagmap bt, bookmark b, tag t\nWHERE bt.tag_id = t.tag_id\nAND (t.name IN ('bookmark', 'webservice', 'semweb'))\nAND b.id = bt.bookmark_id\nGROUP BY b.id"},{"kind":2,"language":"sql","value":"SELECT b. *\nFROM bookmark b, tagmap bt, tag t\nWHERE b.id = bt.bookmark_id\nAND bt.tag_id = t.tag_id \nAND (t.name IN ('Programming', 'Algorithms'))\nAND b.id NOT IN (SELECT b.id FROM bookmark b, tagmap bt, tag t WHERE b.id = bt.bookmark_id AND bt.tag_id = t.tag_id AND t.name = 'Python')\nGROUP BY b.id\nHAVING COUNT( b.id ) =2"},{"kind":1,"language":"markdown","value":"Leaving out the HAVING COUNT leads to the Query for bookmark|webservice-semweb. (an OR, then AND-NOT)"},{"kind":1,"language":"markdown","value":"From: https://www.reddit.com/r/SQL/comments/1hd6cg2/best_tagging_solution_for_an_object_having/\nAlso see: http://howto.philippkeller.com/2005/04/24/Tags-Database-schemas/ \n\nThe “Toxi” solution (3 tables one holds the objects, one holds the tags and their IDs and the other relates them) \n\nThe relationship table object_tags has a primary key which prevents you from adding the same tag to the same object more than once, and which, because it's also an index, allows for rapid retrieval of all tags for a give object\n\nit also has an additional index which allows for rapid retrieval of all objects for a give tag\n\nthus the actual rows of object_tags will never be retrieved, because any query will use one of those two indexes instead (search \"covering query\")\n\nhowever, it does mean that any time you want objects and their tags, or tags and their objects, you will have to do two joins \n\nNeed to work out if any lines need auto-incremented.\n\n\n\nCreate a view that does the joins for you. Then you can query the view. "},{"kind":2,"language":"sql","value":""}]